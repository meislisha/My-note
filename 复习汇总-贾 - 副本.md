
## 一.html,css
### 1.文本标签
	s del 删除 
	b strong 加粗
	i em 切斜
	u ins 
### 2.img
	底部3像素---vertical-align:top/bottom
	转为块级元素
	img 和img之间有缝隙  父元素：font-size:0;
### 3.a锚链接
	可以跨页面 "one.html/#id'
### 4.html的严格模式,html:xt
### 5.5大服务器的内核
		 IE: trident内核       
		 Firefox：gecko内核         
		 Safari:webkit内核
	     Opera:以前是presto内核，Opera现已改用Google Chrome的Blink内核
	     Chrome:Blink(基于webkit，Google与Opera Software共同开发) 
### 7.colspan:列合并.rowspan:行合并
### 10.input中type=hidden,隐藏域
### 11.radio 单选,checkbox多选(加name表明是同一组的),textarea:文本域(cols:列,rows:行)
### 12.iframe:页面中嵌套页面
### 13.span div 无语义
### 14.css三个书写位置:行内式,内嵌式,外联式
### 15 选择器的权重
		!importent>行内>id>类>标签>通配符>继承
		组合权重:(importent,id,类,标签)--直接作用
		不是继承
### 16.a的四个伪元素顺序
		link 还未访问
		visited 访问之后
		hover 悬停
		active 按住不放		
### 17.css三大特性
		层叠性
		继承性
		优先级
### 18.透明度
		rgba : 文字和图片都变透明
		filter:opacity(百分比):只是背景透明
		opacity:0`1
### 19.双倍margin
	ie6之前,当给元素设置float left 和margin-left
	或者float right 和 margin-right
	可能出现双倍margin
	解决方法:display:inline
### 20.a标签跳转-----------target
	_self :当前
	_blank:新窗口
	_top:整个窗口中打开
	__parent:父窗口
	framename：指定窗口中
	    <frame src="pref.html" name="view_frame">
	    <a href="chap3.html" target="view_frame">Chapter 3</a>
	 如果整个页面中的所有超链接都要在新窗口打开：
				<head>
				<base target="_blank">
				</head>
### 21:英文超出换行word-break:break-all;
		超出省略、换行
		换行：word-wrap:word-break;white-space:normal;
		超出省略：text-overflow:ellipsis;overflow:hidden;white-space:nowrap;
### 22.clear right:右边不能有元素(只管自己),clear:left,clear:both同理
### 23.超出部分省略号
			white-space: nowrap;
	        overflow: hidden;
	        text-overflow: ellipsis;
			  line-clamp: 2;		
### 24.清除浮动
#### 1.给父盒子加上高
		只适合高度固定的布局
#### 2.结尾处加空div标签clear:both
		如果页面浮动布局多，就要增加很多空div 
#### 3.父盒子定义overflow:hidden
		不能和position配合使用，因为超出的尺寸的会被隐藏。 
#### 4.单伪元素
		.clearfix::after{
				content:"';
				display:"table"
				clear:both;
			}
		.clearfix{
				zoom:1;
			}
#### 5.双伪元素清除浮动
		.clearfix::after,clear::before{
			content:"';
			display:"table"
		}
		.clearfix::after{
			clear:both;
		}
		.clearfix{
			zoom:1
		}
		原理:
		激活父元素的"hasLayout"属性，让父元素拥有自己的布局。IE 6会读
		取这条命令，其他浏览器则会直接忽略它。
	补充:zoom:1
		当设置了zoom的值之后，所设置的元素就会就会扩大或者缩小，高度宽度就会重新计算了，
这里一旦改变zoom值时其实也会发生重新渲染，运用这个原理，也就解决了ie下子元素浮动
时候父元素不随着自动扩大的问题
### 25.margin的坍陷
	 1.父盒子设置透明边框
		div{
		border:1px solid transparent;
			}
	 2.给父盒子设置overflow:hide
	 3.将margin-top,改成父盒子的padding-top
### 26.怪异盒模型,标准盒模型
		怪异模式主要表现在IE内核的浏览器。当不对doctype进行定义时，会
		触发怪异模式。
	
		1.在标准模式下，一个块的总宽度= width + margin(左右) + 
		padding(左右) + border(左右)
	
		2.在怪异模式下，一个块的总宽度= width + margin(左右)（即width
		已经包含了padding和border值）
		即:box-sizing = border-box

#### BFC --- 块级上下文
		具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外
		面的元素，并且 BFC 具有普通容器所没有的一些特性。
#### 1. 触发条件
		body 根元素
		浮动元素：float 除 none 以外的值;
		绝对定位元素：position (absolute、fixed)
		display 为 inline-block、table-cells、flex
		overflow 除了 visible 以外的值 (hidden、auto、scroll)
#### 2.应用
	1.如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中。
	2.BFC 可以包含浮动的元素（清除浮动）
## 二.js基础
### 1.Infinity:正无穷
### 2.逗号运算符:最后一个表达式的元算是的结果
### 3.+:字符串的拼接,加号
### 4.逻辑运算符的优先级:非(!)>于(&&)>或(||)
### 5.逻辑断路
		&&: 第一个表达式的值可以转化false,第二个不执行,返回第一个	表达式的值
			第一个为true, 返回第二个表达式的值---不一定是布尔
			var n = 0;
	   		var m = -10;
	        var res = n && m;
	        console.log(n); //0
	
		||: 第一个表达式的值可以转化true,第二个不执行,返回第一个表	达式的值
			第一个为false,返回第二个表达式的值---不一定是布尔
	
				 var n = 10;
	    		 var m = -10;
	    		 var res = n || m;
	             console.log(n);//10


### 6.++a,先自增,在参加运算,a++,先运算再自增
### 7.NaN和任意值都不相等包括自身,IsNaN:判断是不是一个NaN;null==undefined
	基本数据类型
		number
		string
		boolean	
		undefined
		null
		NaN		
### 8.number转化""或者" ",结果为0;parseInt,则会转化为NaN
### 9.break:如下可控制break跳出哪层循环
		a:for(var i =0;i<10;i++){
			for(var j =0;j<4;j++){
					if(i+j==10){
						break a;
					}
				}
			}

### 10.可以通过设置数组的length=0,来清空数组
### 11.数组的方法以及常见问题实现的思路
		1.去重
		2.翻转
		3.排序
		4.Array.isAaary()------检测数组
### 12.return 不能换行,换行会默认在后面加上分号,
		return 10;
		return-------->return ; 10; 
		10;
### 13.Data.now():获取当前日期
### 14.Data中获得对应的年月日时分秒
		getTime()  返回毫秒数和valueOf()结果一样
	    getMilliseconds()
	    getSeconds()  返回0-59
	    getMinutes()  返回0-59
	    getHours()   返回0-23
	    getDay()     返回星期几 0周日   6周6
	    getDate()    返回当前月的第几天,当月的几号
	    getMonth()   返回月份，从0开始
	    getFullYear()   返回4位的年份  如 2016//

### 15.new 关键字
	帮我们创建了一个对象
	将this指向当前的对象。
	给对象的属性赋值
	把创建的对象给返回了
### 16.数组的方法
	concat:链接字符串 arr1.concat(arr2)
	join :数组元素连城字符串,arr.jion(")--默认是逗号
#### 1.push:在数组后面加入一个元素,
		arr.push(元素1,元素2,元素3)-------------->push多个元素,
		返回值:数组的长度
#### 2.pop:移出最后一个数组元素
		arr.pop();
		返回值:移出的元素
#### 3.shift:移出数组中的第一个元素
		arr.shift()
		返回值:移出的元素
#### 4.unshift:向数组前面添加一个元素
		arr.unshit(元素1,元素2)
		返回值:数组的长度
#### 5.indexOf:检测数组中是否存在(从前到后)
		返回值:存在-----------元素的下标
				不存在---------(-1)
#### 6.splice:删除数组中的元素
		格式:arr.splice(a,b);a:表示开始的下标,b表示删除的个数
		返回值:删除的那个元素
#### 7.slice:从数组中返回指定的元素
		格式:arr.slice(a,b);a:开始的下标,b:结束的下标(不包括)
		返回值,从数组中返回的新的数组,即不会影响原先的数组
#### 8.Array.from:将字符串分割成数组
		var str = "abcdefg";
		var arr  = Array.from(str);
		console.log(arr);
		//["a", "b", "c", "d", "e", "f", "g"]
#### 9.join:数组中的元素相连成字符串
		格式:arr.join(分隔符);默认以逗号分隔
		var arr = [1,2,3,4,5];
		var str = arr.join("@");
		console.log(str);
		//1@2@3@4@5
#### 10.every:判断数组中的每个元素是不是都满足某个条件
		格式:arr.erery(条件函数)
		条件函数: function(value,index,arr){}--->元素,下标,数组
		返回值:如果数组元素都满足条件函数,则返回true,否则返回false
		如下:
	
		var arr = [1,2,3,4,5];
		function fn(v,i,arr){
			return v>0
		};
		function fn(v,i,arr){
			return v>1
		};
		var flag =  arr.every(fn);
		var flag1 =  arr.every(fn1);
		console.log(flag);//true
		console.log(flag1);//false

### 17.常见运算符的优先级
		(),后自增/自减,非!,正号/负号,前自增/自减  一元运算符
		*,/,%,+,-,关系运算符(>=等),&与,||或,赋值运算符

### 18.常见的排序方法
	1. 冒泡排序
		    var arr = [60,50,40,20,30,10];
			    var count = 0;
			    for(var i = 0 ; i < arr.length-1; i++){  //外层循环控制的是轮数
			       var flag = true;
			    	for(var j = 0 ; j < arr.length-1-i; j++){
			          if(arr[j] < arr[j+1]){
			            var temp = arr[j];
			            arr[j] = arr[j+1];
			            arr[j+1] = temp;
			            flag = false;
			          }
			    	}
			      if(flag){
			        break;
			      }
			      count++;
			    }
	2. 选择排序
		  for(var i = 0 ; i < arr.length-1; i++){
		    	for(var j = i+1 ; j < arr.length; j++){
		    	}
		    }
	3.快速排序
		    function quickSort(arr){
		      if(arr.length) return arr
		      var quickIndex=Math.floor(arr.length/2);
		      var pivo=arr.splice(quickIndex,1)[0]
		      var left=[];var rigt=[]
		      for(var i=0;i<arr.length;i++){
		        if(arr[i<=pivot]){
		          left.push(arr[i])
		        }
		      }
		      qickSort(left).concat([pivot],quickSort[right])
		    }
### 19.变量的预解析
		当在if内声明变量,只会将变量的声明提升,而值留在if语句中
### 20.字符串常用方法
#### 1.charAt() 返回的指定下标的字符。
		var str = "abcdefg";
 		 console.log(str.charAt(3));//d
####２.concat():连接字符串
		var str1 = "abcd";
		var str2 = "efg";
		console.log(str1.concat(str2));
#### 4.indexOf() 返回下标
		  var str = "a1cbacdefg";
 		 console.log(str.indexOf("ac"));//4
#### 5.lastIndexOf()从末尾向前检测
		var str = "acbacdefg";
 		 console.log(str.lastIndexOf("ac"));//3
#### 6.replace()  会得到一个新替换后的值，不会影响原来的字符串
#### 7.slice(开始的下标,个数), 返回指定的字符串
		 var str = "abcdefg";
  		console.log(str.slice(1,4));
#### 8.split() 将字符串以什么分割,返回的是一个数组
		  var str = "abc,edf,haha";
		  var arr = str.split(",");
		  console.log(arr);[abc,edf,haha]
		  console.log(str);
#### 9.trim()去掉前后空格


## 三.DOM
### 1.js的组成
	  a.ECMAScipt  基础语法
	  b.DOM  文档对象模型
	  c.Bom  浏览器对象模型
### 2.设置在style标签内的属性才需要,ele.style.属性名
### 3.表单元素的disabled,checked,selected,可以用true,false表示是否选中
### 4.阻止默认行为
		return false
		e.preventDefaule()
### 5.设置,获取,移除属性
		getAttribute()			attr()/prop()----用于表单的属性取值
		setAttribute()			
		removeAttribute()		removeClass/addClass/                              hasclass/classList
### 6.节点
                 元素节点         属性节点       文本节点          注释节点
    
    nodeType        1                2              3                8
    
    nodeName       标签名            属性名          #text           #comment
    
    nodeValue      null             属性值          文本内容         注释内容
### 7.获取父子兄弟元素
		children                                   children()
		parentNode									parent()
		previousSibling								siblings()
		nextSibling									next()/prev()
		appendChild() 追加							appendTo/append
		cloneNode(true) 克隆 true:深克隆(包括子节点)   clone
		createElement(标签名) 创建元素                 $(字符串)
		父节点.inserBefore(插入的元素,参照元素)		
		removeChild() 删除元素,只能是父元素删除子元素		remove()
		replaceChild(新的元素,替换掉的元素) 替换元素
### 8.事件对象e
	e||window.event 兼容
	
	e.keyCode 按键数字
	
	e.type 事件类型
	
	e.currentTarget 和this是一样的，都代表正在执行这个事件的对象。ie8及以前不支持
	
	e.target 事件触发的源头

### 9.事件对象e.eventPhase 来获取事件的阶段

	  值是1 就是捕获阶段
	  值是2 就是目标阶段，当前触发事件的阶段
	  值是3 就是冒泡阶段
### 10.阻止事件冒泡
		 元素的事件被触发，那个这个元素的所有的父元素，
			他的同类型的事件都会被触发。
		e.stopPropagation()//事件停止扩散 ，ie8及以前不支持
		e.cancelBubble = true//取消冒泡  ie8及以前支持的
### 11.注册事件
#### 1.1.on+事件名称的方式注册事件
		注销 =null
#### 1.2 用addEventListener注册
		removeEventListener(事件名,处理函数,false)
#### 1.3 attachEvent来注册事件
		detachEvent(事件名,处理函数)
### 12 offset 等三大家族见示意图

## 四.BOM
### 1.window对象
#### 1.1 在js中的全局作用域中声明的变量(全局变量)或者函数(全局函数)，都是window对象的属性或者方法。
#### 1.2 window对象自带name值为空字符串,undefined属性,值是undefined
#### 1.3 window对象 
		window.open(网址)打开 
		window.close()关闭 
		window.onload 加载完毕执行  
		window.onunload 页面关闭事件
		window.onresize 当屏幕大小改变时
### 2.location对象
#### 2.1 url = 协议 + ip(域名) + 端口号 +目标资源的路径
				http  www.baidu.com 8080 
#### 2.2 属性
		hash	设置或返回从井号 (#) 开始的 URL（锚）。
		host	设置或返回主机名和当前 URL 的端口号。
		hostname	设置或返回当前 URL 的主机名。
		href	设置或返回完整的 URL。
		pathname	设置或返回当前 URL 的路径部分。
		port	设置或返回当前 URL 的端口号。
		protocol	设置或返回当前 URL 的协议。
		search	设置或返回从问号 (?) 开始的 URL（查询部分）。
#### 2.3 方法
		assign()	加载新的文档。
		reload()	重新加载当前文档。
		replace()	用新的文档替换当前文档。
### 3.history
	history.back()//返回
	history.forward()//前进

### 4.navigator对象包含有关浏览器的信息
	appCodeName	返回浏览器的代码名。
	appMinorVersion	返回浏览器的次级版本。
	appName	返回浏览器的名称。
	appVersion	返回浏览器的平台和版本信息。
	browserLanguage	返回当前浏览器的语言。
	cookieEnabled	返回指明浏览器中是否启用 cookie 的布尔值。
	cpuClass	返回浏览器系统的 CPU 等级。
	onLine	返回指明系统是否处于脱机模式的布尔值。
	platform	返回运行浏览器的操作系统平台。
	systemLanguage	返回 OS 使用的默认语言。
	userAgent	返回由客户机发送服务器的 user-agent 头部的值。
	userLanguage	返回 OS 的自然语言设置。
## 五 jquery
### 1.window.onload和ready()入口函数的区别
	 window.onload必须等到页面内包括图片的所有元素加载完毕后才能执行,且只能编写一次,会被覆盖
	 $(document).ready()是DOM结构绘制完毕后就执行，不必等到加载完毕。可以存在多个不会被覆盖 
### 2.eq选择器
	eq(0):从0开始
### 3.jq中链式编程
	通过return this
	CSS()，index()不行，css返回值是它style的属性值
### 4.dom与jq互转
	dom-->jq $(dom)
	jq-->dom $(dom).get(0)
### 5.自定义属性的取值和设置
#### 5.1jquery
		attr
		<div id="text" value="123"  data_obj="黑哒哒的盟友"><div>
		JQUERY取值：$("#text").attr("data_obj");
		<div id="text" value="123"  data-name="黑哒哒的盟友"><div>
		JQUERY取值：$("#text").data("name");
#### 5.2原生js
		<div id="user" data-id="1234567890" data-name="脚本之家" data-date-of-birth>码头</div>
	
		var userName = plant . getAttribute ( 'data-uname' ) ; // userName = '脚本之家'
		var userId = plant . getAttribute ( 'data-uid' ) ; // userId = '12345'
		
		dataset属性存取data-*自定义属性的值
		console.log(el.dataset.name); // '脚本之家'
		console.log(el.dataset.id); // '1234567890'
		console.log(el.dataset.dateOfBirth); // ''
### 6.常用的方法
		show(),hide().toggle()
		slideUp(),slideDown(),slideToggle()
		fadeIn(),fadeOut(),fadeToggle()
		
		index()获取索引
		end()在链式编程中用，代表回到第一个jquery对象
		stop()停止队列中的一个动画
		clone() 克隆一个元素
		 :checkbox  可以找到所有的复选框
	    :checked 可以找到所有被选中的复选框和单选框
		 prop() 专门用来设置checked seleted disabled属性
### 7.jq中的this
#### 1.注册事件
		dom对象
		原理是根据addEventListener
#### 2.其余方法
		jquery对象
#### 3.处于传参阶段
		     $('input[value=移出]').click(function () {
	
	            // var width = -$(this).width();})
				
		此时this指input

## 六.H5C3
### 1.H5新增的新规范特点
	  1.文档声明,变少了(<!DOCTYPE html>)
	  2.style和script不用写type属性了,默认style的type就是text/css
		script的默认type就是text/javascript
	  3.h5中不需要每个标签都闭合
	  4.小写不敏感,标签用大小写都可以,但一般用小写
### H5新增的内容
#### 1.标签:
		header:头部区域
			nav:导航区域
		main:主体区域
			section:分组区域
				aside:侧栏区域
				article:正文区域
		footer:底部
	
		audio:音频video:视频
			autoplay：自动播放
			loop:循环播放，
		表单元素
			<input type='date'> 日期
			<input type='email'> 邮箱
			<input type='tel'> 电话
			<input type='file'> 上传文件
		表单元素新增属性
			required:所在的imput必须有内容,否则提交时不成功
			autofocus:自动获得焦点
			multiple:主要用在上传文件,代表可以选择多个文件
		progress:进度条
		output:滑块
#### 2.元素选择器
##### 2.1 查找dom的api
		querySelectorAll()--------------拿到的是一个数组
		querySelector()------------------第一个元素
##### 2.2 选择器
		关系选择器
		.active+li:当下一个兄弟元素是li标签时,才会被选中
		.active`li:所有后面的的li标签被选中
		属性选择器
		li[class*='o']-----所有雷鸣中包含o的元素
		li[class$='o']-----类名以o结尾
		li[class^='o']-----类名以o开头的
		伪类选择器
		li:first-child-------第一个li标签,且必须是第一个子元素
		li:last-child -------最后一个里标签,且必须是最后一个子元素
		li:nth-child(n) -------- n从0开始,可以是表达式如 n+2
		li:nth-child(1)第一个元素
		必须是li元素的第n个同时也是第n个子元素;odd奇数,even:偶数
		```````````````````````````````````````````````````		
		li:nth-of-type(n):表示li中的第n个,n从1开始
		伪元素选择器
		P::first-letter ----------- 命中第一个字符
		p::first-line ----------- 命中第一行
		p::selection ------------- 命中选中的行 ---------唯一的新增伪元素
		::placeholder ----------- 选中占位符
		::before,::after -------- 默认行内
#### 3.class方法
		classList-----------类名集合
		classList.add():增加
		classList.remove():移出
		classList.toggle();有就移出,没有就添加
	----------------------------------------------------
		注意:在IE8以及以前的版本都不兼容
		解决方法:
			使用document.createElement()创建元素
			添加到body
			再写样式:要转化称块级元素,因为js创建的元素默认是行内元素
		解决方法2:第三方框架,只有当浏览器的版本是ie8及以下才会执行
				<!--[if lte IE 8]>
			        <script src="js/html5shiv.js"></script>
			    <![endif]-->

#### 4.自定义属性
		格式:data-xxx   data-age data-age-list
		获取:dataset[age]或者dataset.age
		注意驼峰dataset[ageList]
#### 5.动画
##### 5.1 text-shadow:
		x轴方向的阴影   右正
		y轴方向的阴影   下正
		阴影的模糊度
		阴影颜色
##### 5.2盒子阴影
		x轴方向的阴影   右正
		y轴方向的阴影   下正
		阴影的宽度
		阴影的模糊度
		阴影颜色
##### 5.3 transition:all 1s 1s
		参数1:参与过度的属性 
			transition-property
		参数2:过度的时间
			tansition-duration
		参数3:动画效果,linear steps(n)
			transition-timing-function
		参数4:延迟几秒再执行
			transition-delay
##### 5.4 transform:变化
		rotate(30deg):角度,顺时针为正
		scale():缩放,x,y,只写一个代表同时缩放
		translate:平移
			translateX,translateY,translateZ
		transform-origin:设置旋转固定点（以哪个点旋转
		transform: perspective(300px) 视点 一般加在父盒子上
#### 6 background
##### 6.1 多背景图,以逗号相隔
##### 6.2 图片边框,border-image
		必须设置边框的大小
		border-image:url('img/border-oil.jpg') 75;
		border-image-source:图片的来源
		border-image-slice:图片的切割线
#### 7.渐变
##### 7.1 线性渐变
		background:linear-gradient(toright,blue30%,red30%)
		
		参数1：颜色过渡的方向
	            to left   从右到左
	            to right  从左到右
	            to top    从下到上
	            to bottom 从上到下
	
	        还可以传入角度，0度是下面，如果传0度，就是从下到上,顺时针旋转
	
	    参数2：颜色列表，至少需要2个颜色,第一个颜色是开始的颜色，
		具体颜色摆在哪个位置，就看你的一个参数传入的方向，后面可
		以接N多个颜色
##### 7.2径向渐变
		 background: radial-gradient(235px 150px at 
		 center, red, orange);
		 参数1：圆心的位置以及圆的大小
	     参数2：颜色列表，至少需要2个颜色
#### 8.自定义动画
		  animation : autoSwmiming 1s steps(7) infinite;
	  参数1:动画名字
		animation-name
	  参数2:动画时长
		animation-duration
	  参数3:动画效果,linear,或者steps,分步骤
		animation-timing-function
		动画延时
		animation-delay
	  参数4:动画播放次数:
	   反转效果，先瞬间变成动画结束的样子，再以动画慢慢复原
	    animation-direction: reverse; 
	        动画完成后要不要以动画的结束样子显示（不恢复原样）
	    animation-fill-mode: forwards;


		@keyframes autoSwimimimg{
				from{}
				to{}
				}
#### 9.伸缩布局
##### 9.1 display: flex;
		其子元素为伸缩布局,且自动转化为块级元素
##### 9.2 flex-direction:主轴方向
			row:行,colum:列,
##### 9.3 justify-content:主轴方向对齐
			flex-start:起始点对齐
			flex-end:终点对齐
			center:居中
			space-around:四周环绕
			space-between:两端对齐
##### 9.4 align-items:副轴对齐方式
			flex-start:起始点对齐
			flex-end:终点对齐
			center:居中
			stretch:拉伸
##### 9.5 flex-wrap:控制是否换行
			nowrap:不换行
			wrap:自动换行
##### 9.6 align-self:子元素的自己方式-----副轴上
			flex-start:起始点对齐
			flex-end:终点对齐
			center:居中
##### 9.7 flex:控制子元素伸缩比例
#### 10 定位---window.navigator.geolocation.getCurrentPosition()
		window.navigator.geolocation.getCurrentPosition(function (loc) {
	        console.log('您所在的位置纬度是：' + loc.coords.latitude + '经度是：', +loc.coords.longitude);
	    })
#### 11.百度地图API
#### 12.元素拖拽
		元素必须加上 draggable = 'true';
		ondragstart 当元素开始拖拽触发
	    ondrag   当元素正在拖拽触发
	    ondragend 当元素停止拖拽触发
		ondrop 当某个容器检测到有元素移入并且松手后触发

## 七.移动端
### 一.移动web开发
#### 1.开发的两种方式
##### 1.1 响应式开发:一套代码运行多个终端
		优点:开发快,维护快,适配好
		缺点:加载速度慢
		应用:新建的网站(PC和移动同时出来) 对加载速度要求不是很高
##### 1.2 原生移动web开发:一套代码运行一个终端
		优点:加载速度快
		缺点:开发慢,维护慢适配差
		应用:在一些已经有PC端上线的网站 再次开发移动端  
			 移动端需要加载速度很快的网站
#### 2.响应式的原理
##### 2.1 css3媒体查询
		通过查询屏幕的宽度来指定宽度区间的网页布局
##### 2.2 常见的移动设备宽度及bootstrap中的栅格系统对应的类名
			<768px 超小屏幕  手机           xs
			768~992 小屏幕   平板设备		   sm
			992~1200 中屏幕   电脑		   md
			>1200    大屏幕   大屏PC项目     lg

##### 2.3 媒体查询的语法
		 @media screen and (条件){
			//满足条件执行css代码
			}
		
		一般是通过min-width,和max-width来确定
##### 2.4 媒体查询的判断顺序
		向上兼容
		min-width:最小宽度 没有写大的判断 也能生效小屏幕的判断
		判断条件:从小写到大,如下:
			w>768
			w>992
			w>1200
	
		向下覆盖
		max-width:最大宽度 同时写了小和大屏幕的判断 大屏幕在后面会覆盖小屏幕的样式
		判断条件,从大写到小,如下
			 w<1200
			 w<992
			 w<768
	
		也可以  768<width<992
#### 3.px pt em rem vw的介绍
		px:像素（Pixel）。相对长度单位
		pt:印刷业上常使用的单位 pt=px*3/4。
		em:相对长度单位。相对于当前对象内文本的字体尺寸。
			em会继承父级元素的字体大小
		rem:是CSS3新增的一个相对单位（root em，根em）
			html{font-size:100px},body{font-size:16px}
			div{width:0.3rem}------即标准状态下宽为30px
		vw:1vw表示百分之一的视口宽度
		
		移动端响应式布局字体：
			1. html:{font-size: calc(100vw/7.5); }  然后使用rem；但是需要兼容；
			2. 直接js设置
				function changeRootFont() {
				    var designWidth = 750, rem2px = 100;
				    document.documentElement.style.fontSize =
				        ((window.innerWidth / designWidth) * rem2px) + 'px';
				    $('html').css('fontSize', ((window.innerWidth / designWidth) * rem2px) + 'px')
				}
				function resizeFontSize(){
				    changeRootFont();
				    window.addEventListener('resize', changeRootFont, false);
				}
				resizeFontSize()	
### 二.bootstrap的一些介绍
#### 1.特点
		灵活简单,基于jquery
#### 2.核心:栅格系统:如col-md-2:在md宽度下,所占父容器的宽度是2/12
		一般是12列,但是可以根据需求定制
#### 3.常用功能
##### 3.1 导航条
##### 3.2 轮播图
			 轮播图PC端实现： 使用背景图片实现
			 轮播图移动端实现： 使用Img标签
##### 3.3 模态框

### 三.视口
#### 1.视口的一些常见属性
		设置meta标签设置默认是视口的宽度等于设备的宽度
		<meta name="viewport" content="width=device-width">
		
		 初始化缩放 initial-scale=1.0
		 是否允许用户缩放 user-scalable=no
		 最大 maximum-scale=1.0 和最小缩放  minimum-scale=1.0
#### 2.其它设置
		<!-- 忽略识别邮箱，主要是针对安卓手机会自动将符合邮箱格式的字符
		串识别为邮箱地址-->
		<meta content="email=no" name="format-detection" />
		
		<!-- uc强制竖屏 -->
		<meta name="screen-orientation" content="portrait">
		<!-- QQ强制竖屏 -->
		<meta name="x5-orientation" content="portrait">
		<!-- UC强制全屏 -->
		<meta name="full-screen" content="yes">
		<!-- QQ强制全屏 -->
		<meta name="x5-fullscreen" content="true">

### 三.百分比布局和rem布局
#### 1.百分比布局
		给元素设置的宽高都是百分比,参照的是父盒子的宽高,当设备宽度发生改变时,body的
		宽高也会变化,所以设置了百分比的盒子也会发生变化,这就是百分比布局
#### 2.rem布局
		原理:利用的是html的font-size作为参照物,一般设置html{font-size:100px},
		所以此时1rem = 100px,再将body{font-size:16px},作用是将字体的默认大小还
		原,因为在页面中的字体有的需要响应式的变化,有的不需要.再在给页面元素写样式时
		需要变化的属性,如设计图中的宽高为10px,那么可以将宽高设置为0.1rem.然后在通过
		window.onresize事件动态的改变html下font-size的值,即rem的值,从而达到页面
		随屏幕的大小变化而变化,一般我们也会body设置最大宽度和最小宽度,当屏幕大小超出
		范围时,rem不再变化
### 四.移动端常见问题
#### 0.双飞翼布局
		当屏幕变化时,两边的不变,中间的部分随屏幕的宽度变化而变化
		解决方法:
			两边模块用定位,然后大盒子设置padding,从而给两边腾出位置
#### 1.单击事件的300ms延时,
			因为在移动端,双击是有放大效果的,所以在单击以后需要300ms的时间去判断是单击
			还是双击,所以存在300ms的问题
##### 1.1解决方法
			fastClick插件:简而言之，FastClick 在检测到 touchend 事件的时候，
			会通过 DOM 自定义事件立即触发一个模拟click 事件的click事件
		   （自定义事件），并把浏览器在 300 毫秒之后真正触发的 click 事件阻止掉。
##### 1.2原理
			1.在document.body上绑定了click，touchstart，touchend，touchcancel
			  事件	
			2.当点击时,会先触发touchstart事件,然后冒泡到document.body上
			3.然后通过e.taget捕获到触发源,并得到坐标,
			4.当目标元素触发touchend时,冒泡到document.body上,通过e.preventDefault
				阻止,真实的click事件
			5.然后就执行自定义click事件
#### 2.点击穿透
##### 2.1三种现象:
			1.穿透蒙板:如常见的模态框点击关闭,如果模态框点击关闭绑定的touch事件,而模
			  态框下面有元素绑定的是click事件,由于单击延时300ms后触发单击事件,而模态
			  框在这之前就消失了,从而出发了地下元素的单击事件
			2.跨页面点击穿透:如果按钮下面恰好是一个有href属性的a标签，那么页面就会发生
			 跳转因为a标签跳转默认是click事件触发
			3.跨页面点击穿透2:，直接点击页内按钮跳转至新页，然后发现新页面中对应位置元
			  素的click事件被触发了
##### 2.2 解决方法
			 1.不要混用touchheclick
					既然touch之后300ms会触发click，只用touch或者只用click就自然不
					会存在问题了
			 2.只用touch
					把页面内所有click全部换成touch事件
				（touchstart、’touchend’、’tap’），需要特别注意a标签，a标签的href
				 也是click，需要去掉换成js控制的跳转，或者直接改成span + tap控制跳
				 转。毕竟tap需要引入第三方库
			 3.fastClick:要引入库
			 4.给下面的元素拿东西遮挡,当300ms过后在消失
			 5.tap后延迟350ms再隐藏mask,可能有点慢,但改动非常小
			 6.当mask蒙板消失后,给下面的元素添加上pointer-events:none,等350ms过后
				再去掉这个默认样式.

#### 3.1px边框
##### 3.问题描述
		在css设置边框1px,在移动设备中不一定是1px,所以要处理1像素边框
		如iPhone5的宽是320px,但它的分辨率是640px,此时如果css样式设置
		1px,那么在手机中显示会是2px
##### 3.1像素的概念介绍
		设备像素(device pixel, dp)
			物理像素 指设备的分辨率
		css像素:(css pixel, px) 
			虚拟像素,px 是一个相对单位，相对的是设备像素
##### 3.2像素的换算和倍率
			DPR:window.devicePixelRatio
			DPR = 设备像素 / CSS像素 = 屏幕横向设备像素 / 理想视口的宽
			CSS像素 = 设备独立像素 = 逻辑像素
##### 3.3 解决方法
			1.使用border-imag:所以使用的图片是2px高，上部的1px颜色为透明
				缺点:修改颜色麻烦, 需要替换图片
					圆角需要特殊处理，并且边缘会模糊
			2.伪类 + transform 实现
				设置元素相对定位,::after的绝对定位,高为1px,
				然后通过js查询DPR,从而设置transform:scale(0.5)
					transform:scale(0.75)
					if(window.devicePixelRatio && devicePixelRatio >= 2){
							从而给设置准备好的类名,来控制其伪元素的缩放
					}
		解决方法2:
			border-width:thin;

### 4.单页
		内容比父盒子高,但是要求可以滑动,但只有一页
		从html,body,一直到大盒子设置height:100%
		大盒子over-flow:hidden,
		所以大盒子中的内容可以滑动

### 5.去掉滚动条(css3新增伪元素)
			/隐藏横向和纵向滚动条/
			::-webkit-scrollbar {
			width: 0em;
			}
			// 横向滚动条
			body,html{overflow-x:hidden};
			::-webkit-scrollbar:horizontal {
			height: 0em;
			}
::-webkit-scrollbar {
			display:none;
			}
			但是，ios上的滑动效果很不流畅，不利于用户体验，Android上是ok的；此时可以加上这样一句css代码（-webkit-overflow-scrolling: touch;）

### 6.box-sizing = border-box;
		一般用于自适应网页布局,保证布局不会被破坏
### 7.圆角bug:有些安卓手机圆角失败
		background-clip:padding-box;
### 9.transition闪屏
		/设置内嵌的元素在 3D 空间如何呈现：保留3D /
	
		-webkit-transform-style: preserve-3d;
		/ 设置进行转换的元素的背面在面对用户时是否可见：隐藏 /
		
		-webkit-backface-visibility:hidden;
### 10.设置缓存:不希望使用缓存可以设置no-cache。
		<meta http-equiv="Catch-Control" content="no-cache">
### 11. ios 页面卡顿：解决办法;-webkit-overflow-scrolling: touch
## 八.ajax
### 一.C/S,B/S架构
#### C/S:客户端,服务器架构的意思
		优点:
		
		性能较高:可以将一部分的计算工作放在客户端上,这样服务器只需要处理数据即可
		
		界面酷炫:客户端可以使用更多系统提供的效果,做出更为炫目的效果
		
		缺点:
		
		更新软件:如果推出了新版本,不更新客户端无法登陆使用(一部分)
#### B/S:浏览器,服务器架构
		优点
	
		更新简洁:如果需要更新内容了,对开发人员而言需要更改服务器的内容,但是对用户而言只需要刷新浏览器即可
		
		多设备同步:所有数据都在网上,只要能够使用浏览器即可登录使用
		
		缺点:
		
		性能较低:相比于客户端应用性能较低,但是随着硬件性能的提升,这个差距在缩小
		
		浏览器兼容:处理低版本的浏览器显示问题一直是前端开发人员头痛的问题之一,
		移动设备兼容性较好,ie6已经越来越少人用了
		
		不同设备访问:如果使用其他的电脑,没有安装客户端的话就无法登陆软件(比如收发邮件)
### 二.form表单提交数据
#### 1.form发送数据:action指定提交的url,且表单提交默认会跳转刷新页面(onsubmit)

#### 2. method:提交方式,默认是get,表单元素中需要提交的数据,必须舍友name属性
#### 3. get提交数据的本质:在url后面拼接上?key=value&key1=value1,如果自己拼接也能实现数据的传递
#### 4.get提交数据总结:
			数据是拼接在url中
	        数据的安全性不好
	        数据的长度问题
	        理论上来说 url的长度 是可以任意修改的
	        有一些浏览器会限制url的长度
	        有一些服务器 对于长度太长的 url 直接就 屏蔽了
	        测试方便
			可以缓存
#### 5. post提交数据总结:
	    1.提交的数据不在url中
	      安全性好一些
	    2.post提交数据 没有长度限制
	      浏览器端只要你想 随意添加
	      服务器可以选择是否接受这么多的数据
	    3.如果要上传文件 必须使用 post
		4. 不可以缓存
####6.上传文件form表单还需要设置: enctype="multipart/form-data",<input / type="file" name=''>
### 三.发送ajax请求
#### get方式向服务器发哦是那个数据,发送的数据格式是Query S听
#### post方式	向服务发送请求时,发送的数据格式默认是 Request Payload,但服务器大多情况下不会解析,所以让服务器接收post的数据,从而要设置请求头,将数据格式转化为formData;Request Payload用于上传文件
#### 1.五步走
		创建异步对象:var xhr = new XMLHttpRequest();
	
		请求行:如果是get就将数据拼在路径后面
			xhr.open("请求方式","路径")
		
		请求头:get方式不用设置,post方式要设置
			 xhr.setRequestHeader("Content-type","application/x-www-form-urlencoded")
		
		请求主体:get请求为空，或者写null，post请求数据写在这里，如果没有数据，直接为空或者写null
				xhr.send("key1=value1&key2=value2")
	
		回调函数:xhr.onload(也可以)
			xhr.onreadyStatechange = function(){
	
			//判断是否获取成功
		if(xhr.readyState==4&&xhr.status==200){
				xhr.responseText(数据存储)
			
					}
				}
##### 补充:
	xhr.onload = function(){
		if(xhr.status==200)
		} 
		作用一样:xhr.readyState==4(onload就是这个状态)
		readyState:1准备发送
		readyState:2正在发送
		readyState:3准备接受
		readyState:接收成功

#### 2.请求报文,响应报文的组成部分
##### 1.浏览器发送请求报文到服务器,服务器返回响应报文到浏览器
##### 2.请求报文的组成
###### 1.请求行
		1.请求的url
		2.请求的方法
###### 2.请求头
		1.浏览器的一些信息
		2.以及一些想要告诉服务器的信息
###### 3.请求主体
		提交的数据
##### 3.响应报文及组成
###### 1.状态行
		请求是否成功
		常见状态码:
			200 - 请求成功
			204 - 服务器成功处理了请求，但没有返回任何内容。
			301 - 资源（网页等）被永久转移到其它URL
			304 - 如果网页自请求者上次请求后没有更新，则用304代码告诉搜索
				  引擎机器人，可节省带宽和开销。
			400 - 服务器不理解请求的语法。
			404 - 请求的资源（网页等）不存在
			500 - 内部服务器错误
###### 2.响应头
		服务器的一些信息
		服务器想要告诉浏览器的一些信息
###### 3.响应主体
		返回的数据
##### 4.jsonp及跨域
###### 1.同源
		协议,地址,端口都一样
		同源安全策略:浏览器默认限制了跨域的请求
###### 2.跨域
		协议,地址,端口其中一个不相同,就是跨域
		不同源的网站之间发送请求,就称之为跨域访问
###### 3.jsonP(json with Padding)的原理

			动态生成script标签,利用src属性,可以跨域访问(可以请求其它类型的文件,请求回来的内容会以js的形式解析)
			
			发送get请求(在后面拼数据,所以是只能用get请求)
		
			把一个方法的名字发到了服务器(xxxx.pho?callBack=fn())坪街道src后面
			
			服务器返回方法的调用,并且返回函数并将数据待会fn(数据)---------->相当于调用函数fn
##### 5.CORS(Cross-origin resource sharing)
		html5中新增的 兼容性差一些,服务器设置允许跨域即可
		通过Access-Control-Allow-Origin设置允许跨域请求
##### 6.反向代理
		浏览器访问本地服务器---------服务器访问网络服务器------网络服务器返回数据到本地服务-------------本地服务器返回到浏览器		

####  模板引擎的原理
		通过正则表达式,匹配字符串,然后将传入的数据,来代替那些匹配上的字符串,


### 四 雅虎13条优化
##### 1.减少HTTP请求次数
		将页面上的小图片组合成精灵图使用,再由css控制图片的显示
		这样虽然图片的大小不变,但是http的请求系数减少了
##### 2.使用CDN(内容分发网络)
		即当项目较大时,尽量引用网上的库文件,如百度CDN上的库文件,
		这样用户访问时就会去网络服务器上请求,从而减小本地服务器的压力
##### 3.增加Expires Header
		通过使用Expires Header缓存图片文件,脚本文件,样式表等,
		这样也可以减少http的请求次数和大小
##### 4.压缩页面元素
		js,css,html,代码压缩;压缩HTTP响应的内容可减少页面响应的事件
##### 5.把样式表放在头上
		CSS样式表放在head标签中,同样也可以避免结构出来的时候没有样式
##### 6.把脚本文件放在底部
		即js及其库放到页面底部,客养就不会导致阻塞,达到最大的并行下载
##### 7. 避免css表达式
		css表达式的执行次数比较多:如页面显示,resize时,当页面滚屏
		时都会执行;最好用明确的数值代替,或者当腰动态设置的值时,用
		事件处理函数代替
##### 8. 把js和css放到外部文件中
		外部文件会被浏览器缓存,且减少了页面的大小
##### 9. 减少DNS的查询次数
		DNS用于映射主机名和地址,一般一次解析需要20ms--12ms
##### 10. 最小化js代码
		减小文件的大小,加快下载速度
##### 11.避免重定向
##### 12.删除重复的脚本文件
##### 13.缓存ajax
		缓存ajax,减少请求的次数,同样可以加快页面的响应速度;如jq中的$.ajax传参中设置
		cache:true

##### 14.配置ETags


### 四.cookies，sessionStorage和localStorage的区别？
##### sessionStorage
		用于本地存储一个会话（session）中的数据，
		这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。
		因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储
##### localStorage
		用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。
##### 　web storage和cookie的区别
		Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。
		Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，
		这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。
	
		Web Storage拥有setItem,getItem,removeItem,clear等方法，
		不像cookie需要前端开发者自己封装setCookie，getCookie
		。但是Cookie也是不可以或缺的：Cookie的作用是与服务器进行交互，
		作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生。
### 五.预加载及懒加载
#### 1.预加载
		图片预先加载到浏览器中，访问者便可顺利地在你的网站上冲浪，并享受
		到极快的加载速度。这对图片画廊及图片占据很大比例的网站来说十分有
		利，它保证了图片快速、无缝地发布，也可帮助用户在浏览你网站内容时
		获得更好的用户体验。
#### 2.懒加载
		为了提高用户体验,一次性下载图片太浪费流量,所以将图片的路径存在
		自定义属性中, 一开始只会加载在可视区监控滚动事件,当图片出现在课
		时区域内,且图片的src属性为空时,再将图片的路径从自定义属性中取出
		赋给图片的src属性,并且需要定义一个变量用来保存已加载图片的数量,
		这样可以不用每次遍历全部的图片集合.
### 六.三次握手
		第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进
		入SYN_SENT状态，等待服务器确认；SYN：同步序列编号
	
		第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时
		自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入
		SYN_RECV状态；
	
		第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK
		(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP
		连接成功）状态，完成三次握手。

### 七.HTTP,HTTPS协议及TCP协议
		http:
		超文本传输协议 (HTTP-Hypertext transfer protocol) 是一种详
		细规定了浏览器和万维网服务器之间互相通信的规则，通过因特网传送万
		维网文档的数据传送协议。
		https:
		以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL
		层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。
		TCP
		面向连接的、可靠的、基于字节流的传输层通信协议
### 八.xss:跨站脚本攻击
#### 1.原则
		原则：不相信客户输入的数据
#### 2.1.使用XSS Filter
		输入过滤
			对用户提交的数据进行有效性验证,仅接受指定长度范围内并符合我们期望格式的的内容提交，阻止或者忽略除此外的其他任何数据
		输出编码
			当需要将一个字符串输出到Web网页时，同时又不确定这个字符串中
			是否包括XSS特殊字符（如< > &‘”等），为了确保输出内容的完整
			性和正确性，可以使用编码（HTMLEncode）进行处理。
#### 2.2 DOM型的XSS攻击防御
		　把变量输出到页面时要做好相关的编码转义工作，如要输出到 
		  <script>中，可以进行JS编码；要输出到HTML内容或属性，则进行
		  HTML编码处理。根据不同的语境采用不同的编码处理方式。
#### 2.3 HttpOnly Cookie
		  将重要的cookie标记为http only,   这样的话当浏览器向Web服务
		  器发起请求的时就会带上cookie字段，但是在脚本中却不能访问这个
		  cookie，这样就避免了XSS攻击利用JavaScriptdocument.cookie获取cookie
### 九.如何在不刷新页面的情况下改变url

### 十.首屏加载	


## 九.js高阶
### 1. in运算符
#### 1.1 forin ------------ 遍历对象
		for(var key in object)
		forin只能遍历出对象的可枚举属性
		且包装类型用forin遍历不出来其属性
#### 1.2 判断对象是否有某个属性
			(key in obj)
#### 1.3 判断数组是否存在某个下标
		 var foodArr = ['西兰花炒月饼','榴莲炒蛋','西兰花炒榴莲'];
		 console.log('西兰花炒月饼'in foodArr);//false
		 console.log(0 in foodArr);//true
### 3.delete关键字-------删除
#### 3.1.删除没有用var声明的变量
			a = 12;
			delete a;
			console.log(a)--------报错
#### 3.2 删除数组
	 		var arr = [1,2,3];
			delete arr[1]
			console.log(arr[1])--------undefined
#### 3.3 删除对象中的属性
			var person = {
			    name:'厨师',
			    skill:'天天尝菜=>长胖'
			  }
			  person.skill = null;
			  console.log(person.skill);-----null
			  delete person.skill; 
			  console.log(person.skill); --------- undefined
			  for (var key in person) {
			    console.log(key);---- 只能遍历出name,skill被删除了
			  }
### 4.捕获异常
#### 4.1 try-catch-finally
		 try{
		        可能会出错的代码
		        哪怕出错了 后续代码还是会正常执行
		      }
		      catch(data){
		        // 如果出错了 会执行这里的代码
		      }finally{
		        无论包裹的代码是否有问题 都会执行这里面的代码
		        如果有些 无论如何都必须执行的操作 可以放在 finally中
		        比如 释放 变量 person = null;
		      }
#### 4.2 throw 抛出错误
### 5.创建对象的几种方法
		1.var p = new Object()
		2.p={'name':'索隆'} -------- 字面量
		3.工厂模式
			  function objectFac(name,baby){
				      // 创建对象
				      var obj = new Object();
				      // 赋值
				      obj.name = name;
				      obj.baby = baby;
				      // 并返回
				      return obj;
				  }
				 var p3 = objectFac('周杰伦','小周周');
 				 var p4 = objectFac('angelBaby','小baby');
		4.构造函数
			  function Person(name,baby){
			    this.name = name;
			    this.baby = baby;
				this.show=function(){}
			  }
			  var p5 = new Person('邓超','小娘娘');
		缺点：让所有 Person show方法 指向的都是同一个 function

#### 注意new 关键字的作用
	    // 内部 会创建一个对象
	    // 把this指向这个对象
		// 通过this给对象添加属性/方法
	    // 把这个对象返回
#### 使用new fn(),fn内的代码也会执行,出了new的作用,其它的和函数调用一样
### 5.js的三大特性
#### 1.继承性 ------- 一个对象从另一个对象继承属性/方法

#### 2.封装性 
		 封装就是把抽象出来的数据和对数据的操作封装在一起，数据被保护在内部，程序的其它部分只有通过被授权的操作(成员方法)，才能对数据进行操作。

#### 3.多态性 :同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果

### 原型使用注意
	1. 添加跟原型同名的属性，并不会影响原型中的属性，实例化的对象访问属性时,先找自己身上的,没有在原型中找
	2. 原型可以直接赋值一个新的对象
	  function Fruit(name) {
	    this.name = name;
	  }
	  // 直接为原型赋值一个对象
	  Fruit.prototype = {
	    eatType:'吸一口'
	  }
	
	  var fruit1 = new Fruit('百香果');
	  console.log(fruit1.eatType);//'吸一口'
	
	  // 修改原型的对象
	  Fruit.prototype = {
	    // constructor:Fruit,
	    safe:'有些水果不能直接吃'
	  }
	  console.log(fruit1.eatType);//'吸一口'
	  console.log(fruit1.safe);//undefined
	
	  var fruit2 = new Fruit('榴莲');
	  console.log(fruit2.eatType);//undefined
	  console.log(fruit2.safe);//'有些水果不能直接吃'
### 6.继承的几种方式
#### 6.1 混入式
		var o = {};var o1 = {name:'索隆',age:18}
		for(var k in o1){
			o[k]=o1[k]
		}
#### 6.2 原型继承
		var o = {};var o1 = {name:'索隆',age:18}
		o.__proto__ = o1
#### 6.3 原型混入
		var o = {};var o1 = {name:'索隆',age:18}
		for(var k in o1){
			o.__proto__[k]=o1[k]
		}
#### 6.4 经典继承
		var o1 = {name:'索隆',age:18};
		var o = Object.create(o1);
		缺点:ie8及以前不支持
##### 封装兼容
		function create(obj){
			if(Object.create){//支持Object.create()
				return Object.create(obj)
			}
			else{//不支持
				function fn(){};
				fn.prototype=obj;
				obj.constructor = fn;
				new fn()
			}
		}
#### 6.5.通过构造函数继承------利用call/apply
		function fn1(){
			this.name = '索隆';
			this.age = 18;
		}
		function fn(){
			fn1.call(this)
		}
		
		var obj = new fn();
		----------------------------------
		利用new关键字时,this指创建出来的对象,利用函数的调用call/apply改变this的指向
### 7.重载 ---------- 函数名相同,	参数个数不同
	  js中没有重载,但可以模拟重载	
	  js中重复声明同一函数名的函数,后面的会覆盖前面的,所以没有重载,但可以模拟重载
#### 7.1 如jquery中的css(),一个参数是取值,两个参数是设置值
		实现如下:
			function css(key,value){
				if(value){
				 // 两个参数-----设置值
					ele[key] = value
			  }
				else{// 一个参数取值
					return ele[key]
				}
			}
### 8.拓展内置对象 ----------- 如给一个数组添加某个方法
#### 1.如果直接在Array.prototype上加,会影响其数组使用者
#### 2.解决
		function myArr(){};
		myArr.prototype = new Array(); ---- 拥有了数组的方法和属性
		myArr.prototype.addinfo = function(){console.log('新增的方法')} ---- 原型上加方法
		var arr = new myArr() ------ arr有了数组的方法,也有了自身需要的方法

### 9.原型链
#### 9.1 原型三角
		function fn(){}
		var o = new fn()
		fn.prototype.constructor = fn
		//fn.prototype = o.__proto__ -- 不推荐用,不允许实例对象修改原型上的方法或者属性
		o.constructor = fn //继承原型上的属性
#### 9.2 原型链
		 由原型三角引申出来,对象是有原型的,对象的原型也是对象,所以对象的原型也有原型
		 一直找到Object.prototype为止,再上一级就是null
#### 9.3 注意
			所有的函数都是由new Function() 出来的,函数即使函数也是对象
#### 9.4 访问对象的属性和方法,都是从自身开始,找不到再按照原型链一直往上找
			属性找不到 ------ undefined
			方法找不到 ------ 报错

### 10.Object原型上的常见方法
#### 1.hasOwnProperty ---对象自身的属性,原型上的不算
#### 2.obj1.isPrototypeOf(obj2) ---- 对象1是否是对象2的原型,或者原型的原型
#### 3.toString() --------- 转换为字符串
#### 4.valueOf() ---------  取值
### 11.arguments
#### 1.作为函数的属性 -------- 存在于Function原型上
		fn.arguments 
#### 2.函数内部的arguments  ----------  用来获取实参
		可以不写形参
		function(){
		console.log(arguments)
		}
		fn(1,2,3,4)
		伪数组
#### 3.两者并不相等---伪数组--引用类型---不等
### 12.callee和caller
#### 1.caller ---- 函数调用的环境,只有调用才能看到
		function fn(){console.log(fn.caller)};
		fn() ---- 全局调用 打印 null
		function fn1(){fn()};
		fn1() ---- 函数内部调用 打印 fn1
#### 2.arguments.callee ---- 函数内部指向函数本身
		arguments.callee() ------ 函数内部递归调用

### 13.静态成员与实例成员
#### 1.静态成员 ------  透过构造函数来访问的属性和方法
#### 2.实例成员  -----  实例化的对象的属性,方法
### 14.eval() 
	 	可以将字符串转成js代码执行 --- eval('var a = 998');console.log(a) --998
		解析json ----- eval('('+'{"name":"奥特曼"}'+')')
		缺点:
			别人可以随意的输入 js代码 并且被解析为 js
### 15.获取body所有的子元素
#### 1.querySelectorAll('body *:not(script)');
#### 2.递归算法 ---- 找子元素再找子元素的子元素,由简到繁的分析
#### 3.补充:not选择器 ,除掉什么之外
### 16.变量提升
#### 1.变量声明会提到该作用域的顶部,赋值语句留在原地
#### 2.函数的两种声明方式
		var a = function (){} ----- 和普通变量一样,声明提前,赋值留在原地
		function a(){} ------- 整体提升 
#### 3.变量,函数同名 
		变量有值 --------- 是变量
		变量没有值 ------- 是函数


### 15.call和apply --------- 动态的改变this的指向
			 function test(){
			    console.log(this);
			    console.log('test 被调用了');
			    console.log(arguments);
			  }
#### 1.call
		参数1:对象1 --- 参数2-n 
		test.call({name:'jack',skill:'you jump i jump'},'icemountain','robot')
#### 2.apply
		参数1:对象 ---- 参数2:数组伪数组,传递给函数的 实参 只有两个参数
		伪数组中,必须有length属性
		test.apply({name:'rose',skill:'swim'},{0:'jack',1:'rose',length:1});
#### 3.注意点
		 当第一个参数不传,或者为null时,this指向window
		 第一个参数是对象时,则指向该对象
		 第一个参数基本类型时,则指向对应的包装类型
#### 4.call与apply会立即执行函数,bind也可以改变this的指向,但只有调用的时候才会触发,因此改变this的指向有以下几个方法
		1.call/ apply ------- 立即执行
		2.bind ----- 调用才执行
		3.利用变量接受this,参考jquery中的$this = this
		4.箭头函数 -------- 箭头函数的this是其声明环境的this

### 获取类型
	Object.prototype.toString.call();
	Object.prototype.myString=function(){
		var result='[object ';
		result+=this._proto_.constructor.name
		result+=']'
		return result
	}

### 上下文模式实现继承
		function Student(){
		    this.skill = '上课睡觉流口水';
		    this.goodAt = '体育';
		  }
		  function StudentKing(){
		    // 继承普通学员的内容
		    Student.call(this);
		    // 自己的技能
		    this.selfSKill = '这次考得真差';
		  }
### 补充 ------- js高阶常见应用 
#### window下的两个常见属性
		name ----- '' 空字符串
		undefined --- undefined 
#### 严格模式下不同点
##### 1.目的
		1.消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;
		2.消除代码运行的一些不安全之处，保证代码运行的安全；
		3.提高编译器效率，增加运行速度
		4.为未来新版本的Javascript做好铺垫。
#### 2.进入标志
			'use strict'
#### 3.使用的地方
		1.函数内
		2.整个js
#### 4.改变的地方
##### 1.全局变量显示的声明 ----- 不声明,则报错
		'use strict'
			a =1; ---报错,没有显示的声明
##### 2.创设eval作用域
		正常模式下，eval语句的作用域，取决于它处于全局作用域，还是处于函数作用域。
		严格模式下，eval语句本身就是一个作用域
			"use strict";
		　　var x = 2;
		　　console.info(eval("var x = 5; x")); // 5
		　　console.info(x); // 2
##### 3.禁止this关键字指向全局对象
			function f(){
		　　　　return !this;
		　　} 
		　　// 返回false，因为"this"指向全局对象，"!this"就是false
		　　function f(){ 
		　　　　"use strict";
		　　　　return !this;
		　　} 
		　// 返回true，因为严格模式下，this的值为undefined，所以"!this"为true。
		---------------------------------------------------------------
			　function f(){
			　　　　"use strict";
			　　　　this.a = 1;
			　　};
			　　f();// 报错，this未定义undefined
##### 4.禁止在函数内部遍历调用栈
		　　function f1(){
		　　　　"use strict";
		　　　　f1.caller; // 报错
		　　　　f1.arguments; // 报错
		        arguments.callee();// 报错
		　　}
		　　f1();
##### 5. 禁止删除变量 
		严格模式下无法删除变量。只有configurable设置为true的对象属性，才能被删除。
		　"use strict";
		　　var x;
		　　delete x; // 语法错误
		　　var o = Object.create(null, {'x': {
		　　　　　　value: 1,
		　　　　　　configurable: true
		　　}});
		　　delete o.x; // 删除成功
##### 6.对象不能有重名的属性
		　"use strict";
		　　var o = {
		　　　　p: 1,
		　　　　p: 2
		　　}; // 语法错误
##### 7.函数不能有重名的参数
			　"use strict";
		　　function f(a, a, b) { // 语法错误
		　　　　return ;
		　　}
##### 8.arguments对象的限制
		1.不允许对arguments赋值
		2.arguments不再追踪参数的变化
			　function f(a) {
			　　　　a = 2;
			　　　　return [a, arguments[0]];
			　　}
			　　f(1); // 正常模式为[2,2]
			　　function f(a) {
			　　　　"use strict";
			　　　　a = 2;
			　　　　return [a, arguments[0]];
			　　}
			　　f(1); // 严格模式为[2,1]
#### 9.函数必须声明在顶层
		格模式只允许在全局作用域或函数作用域的顶层声明函数。也就是说，
		不允许在非函数的代码块内声明函数。
			　"use strict";
			　　if (true) {
			　　　　function f() { } // 语法错误
			　　}
			　　for (var i = 0; i < 5; i++) {
			　　　　function f2() { } // 语法错误
			　　}


#### 一.将伪数组转化为数组
##### 1.伪数组的特性
		1，具有length属性
		2，按索引方式存储数据
		3，不具有数组的push,pop等方法
		fakeArray = {0:'a',1:'b',length:2}
##### 2.常见的伪数组
		1.函数中的arguments
		2.jquery对象 
		3.js获取的dom对象集合
##### 3.将伪数组转化为数组
###### 1.利用遍历,将伪数组存在空数组中
			var fakeArr = {0:"索隆",1:'路飞',length:2};
			 var a = [];
				for(var i =0;i<fakeArr.length;i++){
					a[i] = fakeArr[i];
				}
				console.log(a);
###### 2.利用call,apply来改变this的指向--------- slice返回的是一个数组
		var a = Array.prototype.slice.call(fakeArr,0);		
		var a = Array.prototype.slice.apply(fakeArr);
		 		console.log(a);
###### 3.ES6新方法------Array.from
		var  a = Array.from(fakeArr);
		console.log(a);
##### 4.利用原型继承,fakeArr.__proto__ = Array.prototype
		fakeArr.__proto__ = Array.prototype;
		fakeArr.push('香吉士');
		console.log(fakeArr)
#### 二.检测数据类型
##### 1.typeOf ---- null 数组 对象的结果都是object
		   console.log(typeof 2); // number
		   console.log(typeof 'sadas'); // string
		   console.log(typeof undefined); // undefined
		   console.log(typeof true); // boolean
		   console.log(typeof null); // object
		   console.log(typeof {});  // object
		   console.log(typeof []);	// object
		   console.log(typeof (function(){})); //function		
##### 2. instanceof ------- 检测对象 instanceof 构造函数
			构造函数有没有在检测对象的原型链上出现过
			console.log([] instanceof(Array))//true
			console.log([] instanceof(Object))//true
			console.log((function fn(){}) instanceof(Object))//true
##### 3.Object.prototype.toString.call()/apply()
		console.log(Object.prototype.toString.call(1));---[object Number]
		console.log(Object.prototype.toString.apply('1'));--[object String]
		console.log(Object.prototype.toString.apply(true));--[object Boolean]
		console.log(Object.prototype.toString.call(undefined));--[object Undefined]
	    console.log(Object.prototype.toString.call(null));--[object Null]
		console.log(Object.prototype.toString.apply([]));--[object Array]
		console.log(Object.prototype.toString.apply({}));--[object Object]
		console.log(Object.prototype.toString.apply(function(){}));--[object Function]
##### 封装检测数据的类型的函数
		 	function classType(obj){
		   		var leix = Object.prototype.toString.call(obj);
		   		//slice:截取字符串,返回的是字符串
		   		leix = leix.slice(8,leix.length-1);
		   		return leix;
		   }
		   console.log(classType([]));
#### 三.写一个log函数代替console.log
##### 1.call --- 参数1:console,参数2:打印的内容
		function log(str){
			console.log.call(console,str)
		}
		log(111111);
##### 2.bind ------ 返回值是一个函数 第一个参数也是this的指向
		var log = console.log.bind(console)
		log(111111);
#### 六.深拷贝和浅拷贝



## 十.jquery中一些常用技巧和模式思想
### 1.自己写jquery插件

### 2.缓存


## 十二.requireJS
### 1.模块化开发的作用
#### 1.减少全局变量的污染
		当我们要实现的功能越来越多,代码也就会越来越多,哪怕我们
		把功能封装城函数,或者时放到对象中,也会导致全局变量的污染
#### 2.更多的复用
		 我们把要实现逻辑代码,按功能分开,这样当我们在多个地方需要
		 用到统一功能的时候,可以依赖于一个已经写好的功能
#### 3.解决功能之间的依赖关系
		 当一个功能依赖于另一个功能时,我们可以利用闭包,向外界提供
		一个接口,让其他模块拿到暴露出去的功能
### 2.模块化实现的方式
#### 1.闭包 -- 沙箱模式 --- 自调用函数
		闭包实现存在缺点
		1.随着功能的增加,暴露的模块入口就会增加(全局变量)
			  也会在一定程度上造成全局变量污染
		2.不能很好的解决模块化依赖的问题 --- 减少了页面对很多js
			文件的引用,影响网页性能

#### 2.使用主流的一些模块化库实现
		requireJS
		seaJS
		webpack
		mv*框架 ----- angular / vue
		组件化 ---- react
		-----------------------------
		requireJS,angular,vue --- SPA(单页应用)
### 2.AMD规范和CMD规范
#### 1.AMD规范 ---- requireJS ---- 异步加载
		异步加载 ---- 动态的创建script标签
		依赖前置 ---- 把所有需要依赖的模块放在文件的头部
#### 2.CMD规范 ----- commonJS/seaJS ---- 同步加载
		依赖就近 ---- 运行代码至需要某个模块的时候才回去加载
#### 3.比较
		AMD在加载模块完成后就会立即执行模块,等所有的模块加载执行
		完毕后,才会去执行主逻辑,即被依赖的模块
		---------------------------------------
		CMD加载完某个依赖的模块后,并不会立即执行,只是下载而已
		在执行主逻辑用到所依赖的模块时才会执行
		---------------------------------------
		AMD用户体验好,依赖模块提前加载执行了,没有延迟
		CMD性能好,因为只有用户需要的时候才会执行

### 3.requireJS的基本使用
		一般讲有返回值的放到前面,a,b作为参数接收返回值
		通过应用返回值,就可以确定模块的执行顺序
#### 1.导入
		require([文件路径(省略js),文件2],function(a,b){
			
		})
#### 2.定义模块
		define([文件1,文件2],function(a,b){
			
		})
#### 3.入口文件
	<script src="require.js" data-main="main"></script>	
	
	data-main:自定义属性确定入口文件
#### 4.配置文件
	require.config({
		    baseUrl:"js",       //设置基础目录
		    paths:{     //paths中每一个路径都不能携带.js后缀名
		        jquery:"lib/jquery-2.1.4",
		        bootstrap:"../assets/bootstrap/js/bootstrap",
		        //jquery用于cookie操作的插件
		        cookie:"lib/jquery.cookie",
		        //requireJS官方提供的用于加载html文件的插件
		        text:"lib/text",
		        //模板文件夹的路径
		        tpls:"../tpls",
		        //配置arttemplate模板引擎的路径
		        template:"lib/template-web"
		    },
	
		------------------------------------------
		如果一个js文件不支持AMD这种模块定义规范(比如
		bootstrap.js)，但是它又依赖于我们定义的模块(jquery)，
		通过以下方式来解决
		
		    shim:{// 依赖配置
		        bootstrap:{ //
		            deps:["jquery"]
		        }
		    }
		
		});
### 5.补充的知识点
#### 1 获得对应的url中的参数
##### 1. location.href="页面地址"	页面跳转
##### 2. location.reload();		页面刷新
##### 3. location.search		获取get请求的参数	http://		www.baidu.com?name=ccc&id=666-->"?name=ccc&id=666"
##### 4.location.hash		获取锚点/锚名		http://	www.baidu.com#ccc	-->"#ccc"
##### 5.location.protocol		获取协议的名称		 	http://www.baidu.com	-->"http:"
##### 6.location.pathname		获取路径名称
#### 2.操作cookie和localstrange --- 存储用户信息
	cookie: 存
	document.cookie = 'id=666' ---存储(id='666';name="索隆")
			取
	var id = getCookieByKey("id") --- 对应的键名
	通过字符串的str.split(";")切割成数组,在str.split("=")即可
	--------------------------------------------
	localStorage:存	
	localStorage.setItem(“键”,” 值”),存储值
			取
	localStorage.getItem(“值”),获取
	----------------------------------------
	jquery.cookie ------ 插件 cookie可以设置时间
	存:$.cookie(“name”,”xd”)
	取:$.cookie(“name”)
	------------------------------------------
	由于款页面传值,只能字符串,所以要将对象{name:"xd",age:18}
	转换为json
	var str = JSON.stringify(obj)
	获取到对应的值后需要,将JSON转换为对象,方便取对应属性值
	var obj=JSON.parse(str);



## 重要模块实现的思路
### 登录注册模块的思路
#### 1.注册
		进入登录页面,用户输入对应的注册信息
		-->做正则判断,如:用户名,密码长度,邮箱以及手机号是否正确
		-->正确,则发送给后台,但不能明文发送,转换为密文传输
			-->利用例如md5加密,md5会生成32位的密文,且是不可逆的,即通过密文无法反推到明文
			-->同时为了保证用户的安全,有时也会在密码后面'加盐',即加一些比较无规律的后缀,在通过MD5转化为密文,
			-->转化为密文后,再发送给服务器,这样安全性就更高了,存在数据库中的是密文形式的密码
		-->用户在登录的时候,也会自动将其密码转换为密文,在去发送,再与后台比较
#### 2.登录:
		输入网址--->一般默认是index.html,通过session判断有没有登录过
		--->有,可以访问--->并且从服务器获取用户信息,渲染如头像,昵称等
		--->没有,则跳转到登录页面--->用户填信息,并且做一些正则验证(密码长度,邮箱等)
		--->先验证验证码,
				--->由于用户众多,怎样才能将每个用户的验证码对应起来
				--->当浏览器给服务器发送请求时,利用后台的session,在后台开辟一个空间给浏览器,将随机生成的验证码,存在session的某个属性中
				--->并将这个空间对应的id通过响应头的传递给浏览器,浏览器将id存在本地cookie中.并且返回验证码
				--->当用户开始验证时,会将id以请求头为载体带给后台,找到对相应的空间,比较提交的验证码和存在session中的验证码是否相同,不相同则直接返回,并生成新的验证码
		--->验证码通过,接着验证用户名和密码
				---->后台从数据库中获取对应的存储用户名的库,然后将用户发送过来的用户名和密码进行查找,
				---->如果找到,则登录成功,如果查找不到,则提示登录失败,并且再次刷新验证码
		--->重复上述过程,直至登陆成功
				---->登陆成功,获取到其基本信息如用户名,头像,并将用户名和对应用户id存在session的属性中,如session.username并且设置时限.
				---->关掉网页再打开时,判断session.usename是否存在,存在即直接打开首页,不存在则跳转到登录页
		------------------------------------------------------------------------------------------------------------------------------------
		有时也会将用户的昵称和一些头像等一些信息存在localstrange中或者cookie中,以便判断打开其它页面或者重新打开页面时,不需要向后台发送请求去获取信息,同样要设置时限

### 2.购物车模块
		   京东:
	    未登录
	        浏览的cookies
	
	    已登录
	        保存到服务器
	
	淘宝:
	    服务器
	----------------------------------------------------------
	cookies:(浏览器本地)
	    优点:
	        减少服务器压力，节省服务器资源  1K  1000万
	
	    缺点:
	        容易丢失用户某次的购买行为
	
	服务器端:
	    优点:
	        不会丢失用户加入购物车中的商品
	        更加利于分析用户的购买行为，给用户推荐，促进更多的交易
	
	    缺点:
	        增加服务器压力，增加服务器的存储空间


​		


​	


​		
​			
​			


​			

​		

### 单页应用闪屏/白屏
### 单页应用的seo优化		




### 检测类型------------待完善
	typeOf()
	instanceof :构造函数的原型是否在对象的原型链上
	Object.prototype.toString.call(arr)-----返回[object Array]字符串
### 重定向.重绘,



### 兼容性
#### 1.innerText和textContent
  都可以获取文本,包括子标签中的文本,也可以设置元素中的文本
  但是不会解析标签
  innerText是ie的东西，FF42之前不支持
  textContent是w3c标准的东西，IE8和他之前不支持。
#### 1.1.兼容性处理,能力检测,利用typeof (不存在也不会报错,可以继续后面的程序)
	function  getText(ele){
	if(typeof ele.textContent == "string"){
	   return ele.textContent;
	}else {
	   return ele.innerText;
	}
  }

	function setText(ele,text){
	if(typeof ele.textContent == "string"){
	  ele.textContent = text;
	}else {
	  ele.innerText = text;
	}
  }
#### 1.2 innerHTML
	innerHTML可以设置标签中的内容，如果原来有内容会覆盖原来的
	内容。如果内容中有标签，是可以把标签给解析出来的。
	没有兼容性问题，所有的浏览器都支持。	
### 2.下一个兄弟元素
#### 2.1 nextSibling nextElementSibling
		nextElementSibling获取到的是下一个元素节点，
		但是ie8不支持。 ie8不支持利用他返回的是undefined。
		
		nextSibling:获取到的是下一个兄弟节点(元素，空文本，非空文本，注释)
#### 2.2兼容
	function getNextElement(ele){
	//能力检测-nodeType==1,为元素节点
	if(ele.nextElementSibling){
	   return ele.nextElementSibling;
	}else{
	  var node = ele.nextSibling;
	  while(node.nodeType != 1){
	    node = node.nextSibling;
	  }
	  return node;
	}
  }
### 3.上一个兄弟元素
#### 3.1 previousSibling 和 previousElementSibling
		previousElementSibling;ie8及以前不支持
		previousSibling:能拿到上一个节点(元素、空文本、非空文本、注释)
#### 3.2 兼容
	function getPreviousElement(ele){
	//能力检测---nodeType==1,为元素节点
	if(ele.previousElementSibling){
	  return ele.previousElementSibling;
	}else {
	  var node = ele.previousSibling;
	  while(node.nodeType != 1){
	    node = node.previousSibling;
	  }
	  return node;
	}
  }
### 4.阻止事件冒泡
#### 4.1
	 e.stopPropagation(); //事件停止扩散 ，ie8及以前不支持
	 e.cancelBubble = true; //取消冒泡  ie8及以前支持的
#### 4.2 兼容
    function stopPropagetion(e){
       if(e&&e.stopPropagation){
    	e.stopPropagation();
    	}else{
    		e.cancelBubble();
    		}
      }
### 5.注册事件兼容处理
	 function addEventListener(obj,type,listener){
	 //能力检测
	 if(obj.addEventListener){
	   obj.addEventListener(type,listener,false);
	 }else if(obj.attachEvent){
	   obj.attachEvent("on"+type,listener);
	 }else {
	   obj["on" + type] = listener;
	 }
   }	
### 6.移除事件兼容
	 function removeEventListener(obj,type,listener){
	//能力检测
	if(obj.removeEventListener){
	  obj.removeEventListener(type,listener);
	}else if(obj.detachEvent){
	  obj.detachEvent("on"+type,listener);
	}else {
	  obj["on"+type] = null;
	}
  }

### 7 event.x和event.y问题
	ie:e事件对象有x,y属性,但没有pageX,pageY属性
	Firefox:e对象有pageX,pageY属性,但是没有x,y属性
	
	解决
		mx = e.x?e.x:e.pageX;
### 8.window.location.href
	IE或者Firefox2.0.x下,可以使用window.location或window.location.href;
	Firefox1.5.x下,只能使用window.location. 
	
	解决:
		使用window.location来代替window.location.href
### 9.自定义属性问题
	问题说明：
		IE下，可以使用获取常规属性的方法来获取自定义属性，也可以使
		用getAttribute() 获取自定义属性；Firefox下，只能使用getAttribute() 获取自定义属性。
	
	解决：
		统一通过getAttribute() 获取自定义属性。




### 5.补充
#### 1.在select下拉框中通过selectedIndex可以获得选中的option的下标
#### 2.number,布尔,string类型不能定义私有属性
	 var a = 10；
  	a.pro = 10；
  	console.log(a.pro + a)；
	NAN number对象不可以定义私有属性 namber+非数字和字符的值
	就等于NaN

	var s = ‘hello’；
	  s.pro = ‘world’；
	  console.log(s.pro + s)；  
	//undefinedhello s位字符串，字符串不可以自定义属性，
	所以s.pro为undefined 字符串做加运算会强制拼接位字符串
#### 3.css阻塞问题
		css加载不会阻塞DOM树的解析
		css加载会阻塞DOM树的渲染
		css加载会阻塞后面js语句的执行、




1.深拷贝一个数据对象：JSON.parse(JSON.stringfy); 
	时间转毫秒 （）.getTime（）
2.点击事件，模态框或layer弹出多层，怎么解决？
	使用unbind().bind()
3.一个页面中一个元素点击无效，工作中遇到的情况
	1.动态加载，绑定的时间的时候，这个绑定的元素还没有渲染在页面上；
	2.元素已经生成，但是被遮挡，（并不是看不见,而是能看到，）  
		css:使用Z-index调节

# 面试
## 1.面试题准备
## 2.有道笔记
		公司信息
		题目
## 3.简历 ------ BOSS直聘
		ui插件刷选 
		项目:vue -- 
		技能点:要熟悉
		负责部分:
				分块
				登录注册 -----  购物车 ---- 微信公众号
## 4.面试 ---- 
		浏览器从输入地址到页面渲染完毕整个过程
		bootstrap的兼容性
		http系列
		1次渲染1万条数据	
		要有底气
		webpack1.x ---- webpack2.0
## 5.介绍项目 ----- 套路
		原型 --- 难题 --- 怎么解决 
		项目难题 ---- 及解答思路 
		webpack详解 ----- 热重载 
		双向数据绑定 -------- 组件传数据






​		


​		
